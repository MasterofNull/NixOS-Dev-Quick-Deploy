{ lib, config, ... }:
let
  cfg = config.mySystem;
  isNvme = cfg.hardware.storageType == "nvme";
  isSsd  = cfg.hardware.storageType == "ssd" || isNvme;
  isHdd  = cfg.hardware.storageType == "hdd";
  hibernate = cfg.deployment.enableHibernation;
in
{
  # I/O scheduler policy by media type.
  # - NVMe: none (device has its own multi-queue logic)
  # - SSD/SATA: mq-deadline (good latency/throughput balance)
  # - HDD: bfq (fairness on rotational media)
  services.udev.extraRules = lib.mkAfter ''
    # NVMe drives
    ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL=="nvme*", \
      TEST=="queue/scheduler", ATTR{queue/scheduler}="none"

    # SATA/SAS SSDs (non-rotational)
    ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL!="nvme*", \
      KERNEL!="zram*", ATTR{queue/rotational}=="0", TEST=="queue/scheduler", \
      ATTR{queue/scheduler}="mq-deadline"

    # HDDs (rotational)
    ACTION=="add|change", SUBSYSTEM=="block", ENV{DEVTYPE}=="disk", KERNEL!="nvme*", \
      KERNEL!="zram*", ATTR{queue/rotational}=="1", TEST=="queue/scheduler", \
      ATTR{queue/scheduler}="bfq"
  '';

  # Periodic TRIM for SSDs and NVMe (ext4 / btrfs).
  services.fstrim = lib.mkIf isSsd {
    enable = lib.mkDefault true;
    interval = lib.mkDefault "weekly";
  };

  # NVMe/HDD-specific kernel params.
  boot.kernelParams = lib.mkAfter (
    lib.optionals isNvme [
      "nvme_core.default_ps_max_latency_us=5500"  # Allow deeper APST states
    ]
    ++ lib.optionals isHdd [
      "elevator=bfq"
    ]
  );

  # ---------------------------------------------------------------------------
  # Hibernation / resume (gates on deployment.enableHibernation)
  # ---------------------------------------------------------------------------
  # swapDevices and boot.resumeDevice are generated by the deploy script
  # when enableHibernation=true because the exact device UUID must be known
  # at generation time. The resume-offset for file-backed swap is also
  # script-generated. These two options therefore remain as @PLACEHOLDER@
  # tokens in configuration.nix when hibernation is enabled.
  #
  # What IS declarative here: the sleep config and power management wiring.
  systemd.sleep.extraConfig = lib.mkIf hibernate ''
    # Hibernate after 2 hours of suspend (preserves battery on mobile).
    HibernateDelaySec=2h
    SuspendState=mem
    HibernateMode=platform shutdown
  '';

  powerManagement = lib.mkIf hibernate {
    enable = lib.mkDefault true;
  };
}
