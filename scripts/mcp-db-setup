#!/usr/bin/env sh
# =============================================================================
# MCP Database Stack Validator
# =============================================================================
# Confirms that PostgreSQL, Redis, and Qdrant are running with the expected
# settings for MCP tooling. The script keeps output human-readable so operators
# can triage failures without digging through systemd logs.
# -----------------------------------------------------------------------------
# Environment overrides:
#   PGPASSWORD  â†’ password for the `mcp` PostgreSQL user (export before running)
# =============================================================================

set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
# shellcheck source=../config/service-endpoints.sh
source "$SCRIPT_DIR/config/service-endpoints.sh"

PG_HOST="${POSTGRES_HOST:-${SERVICE_HOST:-localhost}}"
PG_PORT="${POSTGRES_PORT}"
REDIS_PORT="${REDIS_PORT}"
QDRANT_HTTP_PORT="${QDRANT_PORT}"

# -----------------------------------------------------------------------------
# Shared helpers
# -----------------------------------------------------------------------------
log() {
  printf '%s %s\n' "$(date -Iseconds)" "$*"
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

service_status() {
  service="$1"
  start_hint="$2"

  if ! command_exists systemctl; then
    log "[WARN] systemctl not available; skipping ${service} status check"
    return 0
  fi

  if sudo systemctl is-active --quiet "$service"; then
    log "[OK] ${service} service is active"
  else
    log "[WARN] ${service} is not running"
    log "      Start with: ${start_hint}"
  fi
}

check_postgres() {
  log "Checking PostgreSQL (mcp, mcp_tools, mcp_logs)"
  if ! command_exists psql; then
    log "[ERROR] psql command not found. Install postgresql client tools."
    return 1
  fi

  status=0
  for db in mcp mcp_tools mcp_logs; do
    if PGPASSWORD="${PGPASSWORD:-}" psql "postgresql://mcp@${PG_HOST}:${PG_PORT}/${db}" -c 'SELECT 1;' >/dev/null 2>&1; then
      log "[OK] Connected to database '${db}' as user mcp"
    else
      log "[ERROR] Unable to connect to database '${db}' as user mcp"
      status=1
    fi
  done
  return $status
}

check_redis() {
  log "Checking Redis (${SERVICE_HOST:-localhost}:${REDIS_PORT}, 512MB LRU)"
  if ! command_exists redis-cli; then
    log "[ERROR] redis-cli command not found. Install redis client tools."
    return 1
  fi

  if redis-cli -h "${SERVICE_HOST:-localhost}" -p "${REDIS_PORT}" PING >/dev/null 2>&1; then
    log "[OK] Redis responded to PING"
  else
    log "[ERROR] Unable to reach Redis at ${SERVICE_HOST:-localhost}:${REDIS_PORT}"
    return 1
  fi

  maxmemory="$(redis-cli -h "${SERVICE_HOST:-localhost}" -p "${REDIS_PORT}" CONFIG GET maxmemory | awk 'NR==2 {print}')"
  policy="$(redis-cli -h "${SERVICE_HOST:-localhost}" -p "${REDIS_PORT}" CONFIG GET maxmemory-policy | awk 'NR==2 {print}')"
  log "      maxmemory=${maxmemory:-unknown} bytes policy=${policy:-unknown}"
  return 0
}

check_qdrant() {
  log "Checking Qdrant (http://${SERVICE_HOST:-localhost}:${QDRANT_HTTP_PORT}/readyz)"
  if ! command_exists curl; then
    log "[ERROR] curl command not found. Install curl to verify Qdrant."
    return 1
  fi

  if response="$(curl -fsS http://${SERVICE_HOST:-localhost}:${QDRANT_HTTP_PORT}/readyz 2>/dev/null)"; then
    log "[OK] Qdrant readiness: ${response}"
  else
    log "[ERROR] Unable to reach Qdrant on port ${QDRANT_HTTP_PORT}"
    return 1
  fi
  return 0
}

main() {
  log "Model Context Protocol database validation started"

  service_status postgresql "sudo systemctl start postgresql"
  service_status redis-mcp "sudo systemctl start redis-mcp"
  service_status qdrant "sudo systemctl start qdrant"

  rc=0
  check_postgres || rc=1
  check_redis || rc=1
  check_qdrant || rc=1

  if [ "$rc" -eq 0 ]; then
    log "All MCP data services are healthy"
  else
    log "One or more MCP data services reported issues"
  fi
  return $rc
}

main "$@"
