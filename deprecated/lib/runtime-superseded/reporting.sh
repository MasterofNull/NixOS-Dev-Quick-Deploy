#!/usr/bin/env bash
#
# Deployment Reporting
# Purpose: Generate comprehensive post-deployment reports
# Version: 4.0.0
#
# ============================================================================
# DEPENDENCIES
# ============================================================================
#
# Required Libraries:
#   - lib/logging.sh → log() function
#   - lib/user-interaction.sh → print_* functions
#   - lib/colors.sh → Color codes
#
# Exports:
#   - print_post_install() → Generate comprehensive deployment report
#
# ============================================================================

# Track nixos-option invocation context and deduplicate verify output (used by
# `print_post_install` when evaluating modules).
declare -a REPORTING_NIXOS_OPTION_CMD=()
REPORTING_NIXOS_OPTION_CONTEXT=""
# Track hashed systemd-analyze warnings across units; associative arrays are not
# available when bash runs in POSIX mode on some hosts, so use a plain list.
declare -a REPORTING_SYSTEMD_VERIFY_CACHE_KEYS=()
# Certain host-managed services (e.g., tmpfiles resetup) are generated by NixOS
# automatically and do not have declarative definitions; avoid noisy warnings.
declare -a REPORTING_HOST_MANAGED_UNITS=(
    "systemd-tmpfiles-resetup.service"
)

_reporting_verify_cache_contains() {
    local needle="$1"
    local existing
    for existing in "${REPORTING_SYSTEMD_VERIFY_CACHE_KEYS[@]}"; do
        if [[ "$existing" == "$needle" ]]; then
            return 0
        fi
    done
    return 1
}

_reporting_is_host_managed_unit() {
    local unit="$1"
    local skip_unit
    local normalized="${unit%.service}"
    for skip_unit in "${REPORTING_HOST_MANAGED_UNITS[@]}"; do
        local skip_normalized="${skip_unit%.service}"
        if [[ "$unit" == "$skip_unit" || "$normalized" == "$skip_normalized" ]]; then
            return 0
        fi
    done
    return 1
}

_reporting_unit_fragment_is_nixos_managed() {
    local fragment_path="$1"

    if [[ -z "$fragment_path" || "$fragment_path" == "unknown" ]]; then
        return 1
    fi

    local resolved_path
    resolved_path=$(readlink -f "$fragment_path" 2>/dev/null || true)
    if [[ -z "$resolved_path" ]]; then
        return 1
    fi

    case "$resolved_path" in
        /nix/store/*-unit-*.service|\
/nix/store/*-unit-*.socket|\
/nix/store/*-unit-*.target|\
/nix/store/*-unit-*.path|\
/nix/store/*-unit-*.timer|\
/nix/store/*-unit-*.mount|\
/nix/store/*-system-units/*|\
/nix/store/*/etc/systemd/system/*|\
/nix/store/*/lib/systemd/system/*)
            return 0
            ;;
    esac

    return 1
}

# ============================================================================
# Summarize nixos-rebuild Service Activity
# ============================================================================
# Purpose: Inspect nixos-rebuild logs to identify service restarts
# Returns:
#   0 - Always succeeds (pure reporting utility)
# Parameters:
#   $1 - Path to nixos-rebuild log (default: $TMP_DIR/nixos-rebuild.log)
# ============================================================================
# Helper used by print_post_install to display which units were stopped,
# started, or restarted during the most recent nixos-rebuild. Expects log lines
# from `nixos-rebuild switch`.
summarize_nixos_rebuild_services() {
    local tmp_dir="${TMP_DIR:-/tmp}"
    local log_path="${1:-${tmp_dir}/nixos-rebuild.log}"

    if [[ ! -f "$log_path" ]]; then
        print_info "nixos-rebuild log not found at $log_path; skipping service summary."
        return 0
    fi

    if [[ ! -s "$log_path" ]]; then
        print_info "nixos-rebuild log at $log_path is empty; skipping service summary."
        return 0
    fi

    local parsed
    parsed=$(awk '
function flush()
{
    if (state == "") {
        return
    }

    gsub(/[[:space:]]+$/, "", units)
    gsub(/\.$/, "", units)
    gsub(/ and /, ", ", units)

    n = split(units, arr, /, */)
    for (i = 1; i <= n; i++) {
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", arr[i])
        if (arr[i] != "") {
            printf("%s|%s\n", state, arr[i])
        }
    }

    state = ""
    units = ""
}

BEGIN {
    IGNORECASE = 1
    state = ""
    units = ""
}

/^stopping the following units:/ {
    flush()
    state = "stopped"
    units = $0
    sub(/^.*: */, "", units)
    next
}

/^starting the following units:/ {
    flush()
    state = "started"
    units = $0
    sub(/^.*: */, "", units)
    next
}

/^restarting the following units:/ {
    flush()
    state = "restarted"
    units = $0
    sub(/^.*: */, "", units)
    next
}

/^reloading the following units:/ {
    flush()
    state = "reloaded"
    units = $0
    sub(/^.*: */, "", units)
    next
}

/^warning: the following units failed:/ {
    flush()
    state = "failed"
    units = $0
    sub(/^.*: */, "", units)
    next
}

state != "" && $0 ~ /^[[:space:]]+/ {
    more = $0
    sub(/^[[:space:]]*/, "", more)
    units = units " " more
    next
}

state != "" {
    flush()
}

END {
    flush()
}
' "$log_path")

    if [[ -z "$parsed" ]]; then
        print_info "nixos-rebuild log did not record any service stop/start events."
        return 0
    fi

    print_info "Analyzing nixos-rebuild service activity from $log_path"

    local -a stopped_units=()
    local -a started_units=()
    local -a restarted_units=()
    local -a reloaded_units=()
    local -a failed_units=()
    local -a all_units=()

    declare -A seen_stopped=()
    declare -A seen_started=()
    declare -A seen_restarted=()
    declare -A seen_reloaded=()
    declare -A seen_failed=()
    declare -A seen_unit=()

    local action
    local unit

    while IFS='|' read -r action unit; do
        case "$action" in
            stopped)
                if [[ -z "${seen_stopped[$unit]:-}" ]]; then
                    stopped_units+=("$unit")
                    seen_stopped[$unit]=1
                fi
                ;;
            started)
                if [[ -z "${seen_started[$unit]:-}" ]]; then
                    started_units+=("$unit")
                    seen_started[$unit]=1
                fi
                ;;
            restarted)
                if [[ -z "${seen_restarted[$unit]:-}" ]]; then
                    restarted_units+=("$unit")
                    seen_restarted[$unit]=1
                fi
                ;;
            reloaded)
                if [[ -z "${seen_reloaded[$unit]:-}" ]]; then
                    reloaded_units+=("$unit")
                    seen_reloaded[$unit]=1
                fi
                ;;
            failed)
                if [[ -z "${seen_failed[$unit]:-}" ]]; then
                    failed_units+=("$unit")
                    seen_failed[$unit]=1
                fi
                ;;
        esac

        if [[ -z "${seen_unit[$unit]:-}" ]]; then
            all_units+=("$unit")
            seen_unit[$unit]=1
        fi
    done <<< "$parsed"

    local summary_printed=false

    if (( ${#stopped_units[@]} > 0 )); then
        summary_printed=true
        print_info "Stopped services during nixos-rebuild:"
        local stopped
        for stopped in "${stopped_units[@]}"; do
            print_detail "$stopped"
        done
    fi

    if (( ${#started_units[@]} > 0 )); then
        summary_printed=true
        print_info "Started services during nixos-rebuild:"
        local started
        for started in "${started_units[@]}"; do
            print_detail "$started"
        done
    fi

    if (( ${#restarted_units[@]} > 0 )); then
        summary_printed=true
        print_info "Restarted services during nixos-rebuild:"
        local restarted
        for restarted in "${restarted_units[@]}"; do
            print_detail "$restarted"
        done
    fi

    if (( ${#reloaded_units[@]} > 0 )); then
        summary_printed=true
        print_info "Reloaded services during nixos-rebuild:"
        local reloaded
        for reloaded in "${reloaded_units[@]}"; do
            print_detail "$reloaded"
        done
    fi

    if (( ${#failed_units[@]} > 0 )); then
        summary_printed=true
        print_warning "Units reported as failed during nixos-rebuild:"
        local failed
        for failed in "${failed_units[@]}"; do
            print_detail "$failed"
        done
    fi

    if ! $summary_printed; then
        print_info "No service changes were recorded in the nixos-rebuild log."
    fi

    if (( ${#all_units[@]} > 0 )); then
        inspect_service_units_configuration "${all_units[@]}"
    fi

    return 0
}

# ============================================================================
# Inspect Service Configuration for Impacted Units
# ============================================================================
# Purpose: Review systemd metadata for units touched during nixos-rebuild
# Parameters:
#   $@ - Systemd unit names to inspect
# ============================================================================
inspect_service_units_configuration() {
    if (( $# == 0 )); then
        return 0
    fi

    if ! command -v systemctl >/dev/null 2>&1; then
        print_warning "systemctl not available; skipping service configuration inspection."
        return 0
    fi

    print_info "Reviewing configuration for impacted systemd units:"

    local has_nixos_option=false
    if _prepare_nixos_option_context; then
        has_nixos_option=true
        if [[ -n "$REPORTING_NIXOS_OPTION_CONTEXT" ]]; then
            print_detail "nixos-option scope: $REPORTING_NIXOS_OPTION_CONTEXT"
        fi
    else
        print_detail "nixos-option command not found; skipping declarative definition lookup."
    fi

    local has_journalctl=false
    if command -v journalctl >/dev/null 2>&1; then
        has_journalctl=true
    fi

    local has_systemd_analyze=false
    if command -v systemd-analyze >/dev/null 2>&1; then
        has_systemd_analyze=true
    else
        print_detail "systemd-analyze command not found; skipping systemd verification checks."
    fi

    local unit
    for unit in "$@"; do
        inspect_single_service_unit "$unit" "$has_nixos_option" "$has_journalctl" "$has_systemd_analyze"
    done

    return 0
}

# ============================================================================
# Declarative Lookup & Verification Helpers
# ============================================================================

_prepare_nixos_option_context() {
    REPORTING_NIXOS_OPTION_CMD=()
    REPORTING_NIXOS_OPTION_CONTEXT=""

    if ! command -v nixos-option >/dev/null 2>&1; then
        return 1
    fi

    local host_name="${HOSTNAME:-}"
    if [[ -z "$host_name" ]]; then
        host_name=$(hostname 2>/dev/null || true)
    fi

    if [[ -n "${SYSTEM_CONFIG_FILE:-}" && -f "$SYSTEM_CONFIG_FILE" ]]; then
        REPORTING_NIXOS_OPTION_CMD=(env "NIXOS_CONFIG=$SYSTEM_CONFIG_FILE" nixos-option)
        REPORTING_NIXOS_OPTION_CONTEXT="NIXOS_CONFIG=$SYSTEM_CONFIG_FILE"
        return 0
    fi

    if [[ -n "${HM_CONFIG_DIR:-}" && -f "$HM_CONFIG_DIR/flake.nix" && -n "$host_name" ]]; then
        REPORTING_NIXOS_OPTION_CMD=(nixos-option "--flake" "$HM_CONFIG_DIR#$host_name")
        REPORTING_NIXOS_OPTION_CONTEXT="flake ${HM_CONFIG_DIR}#${host_name}"
        return 0
    fi

    REPORTING_NIXOS_OPTION_CMD=(nixos-option)
    REPORTING_NIXOS_OPTION_CONTEXT="default /etc/nixos/configuration.nix"
    return 0
}

_nixos_option_path_exists() {
    local option_path="$1"
    if (( ${#REPORTING_NIXOS_OPTION_CMD[@]} == 0 )); then
        return 1
    fi

    "${REPORTING_NIXOS_OPTION_CMD[@]}" --json "$option_path" >/dev/null 2>&1
}

_system_config_declares_service() {
    local service_name="$1"

    if [[ -z "$service_name" || -z "${SYSTEM_CONFIG_FILE:-}" || ! -f "$SYSTEM_CONFIG_FILE" ]]; then
        return 1
    fi

    local search_pattern="systemd.services.\"$service_name\""
    if command -v rg >/dev/null 2>&1; then
        rg --fixed-strings --quiet "$search_pattern" "$SYSTEM_CONFIG_FILE" >/dev/null 2>&1
    else
        grep -Fq "$search_pattern" "$SYSTEM_CONFIG_FILE" >/dev/null 2>&1
    fi
}

_reporting_lookup_service_option_path() {
    local unit="$1"
    local normalized="${unit%.service}"

    local -a option_paths=()
    case "$normalized" in
        dbus)
            option_paths=("services.dbus.enable")
            ;;
        polkit)
            option_paths=("security.polkit.enable")
            ;;
    esac

    if (( ${#option_paths[@]} == 0 )); then
        return 1
    fi

    local option_path
    for option_path in "${option_paths[@]}"; do
        if _nixos_option_path_exists "$option_path"; then
            echo "$option_path"
            return 0
        fi
    done

    return 1
}

_report_systemd_verify_output() {
    local unit="$1"
    local fragment_path="$2"
    local verify_output="$3"
    shift 3 || true

    local -a new_lines=()
    local line
    local -a context_tokens=("$unit")
    if [[ -n "$fragment_path" && "$fragment_path" != "unknown" ]]; then
        context_tokens+=("$fragment_path")
    fi

    while IFS= read -r line; do
        line=$(_trim_whitespace "$line")
        if [[ -z "$line" ]]; then
            continue
        fi

        local line_matches_context=false
        local token
        for token in "${context_tokens[@]}"; do
            if [[ -n "$token" && "$line" == *"$token"* ]]; then
                line_matches_context=true
                break
            fi
        done

        if [[ "$line_matches_context" == false ]]; then
            if [[ "$line" =~ \.(service|socket|target|timer|path|slice|mount): ]]; then
                continue
            fi
        fi

        local cache_key
        cache_key=$(printf '%s' "$line" | sha256sum | cut -d' ' -f1)

        if ! _reporting_verify_cache_contains "$cache_key"; then
            REPORTING_SYSTEMD_VERIFY_CACHE_KEYS+=("$cache_key")
            new_lines+=("$line")
        fi
    done <<< "$verify_output"

    if (( ${#new_lines[@]} > 0 )); then
        print_warning "systemd-analyze verify reported potential issues for $unit:"
        local message
        for message in "${new_lines[@]}"; do
            print_detail "  $message"
        done
    else
        print_detail "systemd-analyze verify for $unit only reported issues already surfaced; skipping duplicate warning."
    fi
}

# ============================================================================
# Unit Definition Analysis Helpers
# ============================================================================

_trim_whitespace() {
    local value="$1"
    # shellcheck disable=SC2001
    value=$(printf '%s' "$value" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    printf '%s' "$value"
}

_strip_exec_prefix() {
    local command="$1"
    while [[ "$command" == [-@+!]* ]]; do
        command="${command:1}"
    done
    printf '%s' "$command"
}

_print_unit_relationships() {
    local label="$1"
    local relationships="$2"

    if [[ -z "$relationships" || "$relationships" == "-" ]]; then
        return
    fi

    # systemctl show renders relationships as a space-delimited list that may span
    # multiple lines. Normalizing via read -a handles both cases without invoking
    # external tools.
    local -a items=()
    read -r -a items <<< "$relationships"

    if (( ${#items[@]} == 0 )); then
        return
    fi

    print_detail "$label:"
    local dep
    for dep in "${items[@]}"; do
        print_detail "  - $dep"
    done
}

_sanitize_quoted_path() {
    local path="$1"
    path="${path%\"}"
    path="${path#\"}"
    path="${path%\'}"
    path="${path#\'}"
    printf '%s' "$path"
}

_analyze_unit_definition() {
    local unit="$1"
    local definition="$2"

    local line
    local trimmed
    local working_directory=""
    local service_user=""
    local service_group=""
    local -a env_files=()
    local -a exec_entries=()

    while IFS= read -r line; do
        trimmed=$(_trim_whitespace "$line")
        if [[ -z "$trimmed" || "$trimmed" == \#* ]]; then
            continue
        fi

        case "$trimmed" in
            WorkingDirectory=*)
                working_directory="${trimmed#WorkingDirectory=}"
                ;;
            EnvironmentFile=*)
                env_files+=("${trimmed#EnvironmentFile=}")
                ;;
            User=*)
                service_user="${trimmed#User=}"
                ;;
            Group=*)
                service_group="${trimmed#Group=}"
                ;;
            ExecStart=*|ExecStartPre=*|ExecStartPost=*|ExecStop=*|ExecStopPost=*|ExecReload=*)
                exec_entries+=("${trimmed#*=}")
                ;;
        esac
    done <<< "$definition"

    if [[ -n "$service_user" ]]; then
        if [[ "$service_user" == *%* ]]; then
            print_detail "Service user uses template specifiers: $service_user"
        elif command -v id >/dev/null 2>&1; then
            if id "$service_user" >/dev/null 2>&1; then
                print_detail "Runs as user: $service_user"
            else
                print_warning "Configured user '$service_user' for $unit does not exist on this system."
            fi
        else
            print_detail "Unable to verify user $service_user (id command unavailable)."
        fi
    fi

    if [[ -n "$service_group" ]]; then
        if [[ "$service_group" == *%* ]]; then
            print_detail "Service group uses template specifiers: $service_group"
        elif command -v getent >/dev/null 2>&1; then
            if getent group "$service_group" >/dev/null 2>&1; then
                print_detail "Runs as group: $service_group"
            else
                print_warning "Configured group '$service_group' for $unit does not exist on this system."
            fi
        else
            print_detail "Unable to verify group $service_group (getent unavailable)."
        fi
    fi

    if [[ -n "$working_directory" ]]; then
        local dir_path="$working_directory"
        dir_path=$(_sanitize_quoted_path "$dir_path")
        if [[ -d "$dir_path" ]]; then
            print_detail "Working directory: $dir_path"
        else
            print_warning "Working directory $dir_path does not exist; service may fail to start."
        fi
    fi

    local env_file
    for env_file in "${env_files[@]}"; do
        local optional=false
        if [[ "$env_file" == -* ]]; then
            optional=true
            env_file="${env_file#-}"
        fi
        env_file=$(_sanitize_quoted_path "$env_file")
        if [[ "$env_file" == *%* ]]; then
            print_detail "Environment file path uses template specifiers: $env_file"
        elif [[ -f "$env_file" ]]; then
            print_detail "Environment file present: $env_file"
        elif [[ "$optional" == true ]]; then
            print_detail "Optional environment file missing (allowed): $env_file"
        else
            print_warning "Environment file $env_file missing; variables may be undefined."
        fi
    done

    local exec_entry
    for exec_entry in "${exec_entries[@]}"; do
        local command_block
        IFS=';' read -r -a command_block <<< "$exec_entry"
        local command
        for command in "${command_block[@]}"; do
            command=$(_trim_whitespace "$command")
            if [[ -z "$command" ]]; then
                continue
            fi
            command=$(_strip_exec_prefix "$command")
            if [[ -z "$command" ]]; then
                continue
            fi
            local executable _rest
            read -r executable _rest <<< "$command"
            executable=$(_sanitize_quoted_path "$executable")
            if [[ "$executable" == *%* ]]; then
                print_detail "Executable path uses template specifiers: $executable"
                continue
            fi
            if [[ "$executable" == /* ]]; then
                if [[ ! -x "$executable" && ! -f "$executable" ]]; then
                    print_warning "Executable referenced by unit is missing or not executable: $executable"
                fi
            fi
        done
    done
}

# ============================================================================
# Inspect Individual Service Unit
# ============================================================================
# Purpose: Gather diagnostic metadata for a specific systemd unit
# Parameters:
#   $1 - Unit name (e.g., postgresql.service)
#   $2 - Whether nixos-option is available (true/false)
#   $3 - Whether journalctl is available (true/false)
#   $4 - Whether systemd-analyze is available (true/false)
# ============================================================================
inspect_single_service_unit() {
    local unit="$1"
    local has_nixos_option="$2"
    local has_journalctl="$3"
    local has_systemd_analyze="$4"

    echo ""
    print_info "Service diagnostics: $unit"

    local show_output
    if ! show_output=$(systemctl show "$unit" \
        -p LoadState \
        -p ActiveState \
        -p SubState \
        -p UnitFileState \
        -p FragmentPath \
        -p Description \
        -p Result \
        -p ExecMainStatus \
        -p ConditionResult \
        -p AssertResult \
        -p Type \
        -p Restart \
        -p Wants \
        -p Requires \
        -p WantedBy \
        -p RequiredBy \
        -p Before \
        -p After \
        -p PartOf \
        -p Conflicts \
        -p Triggers \
        -p TriggeredBy 2>/dev/null); then
        print_warning "systemd does not recognize $unit; verify the unit name and configuration."
        return 0
    fi

    declare -A props=()
    local line
    while IFS='=' read -r key value; do
        if [[ -z "$key" ]]; then
            continue
        fi
        props[$key]="$value"
    done <<< "$show_output"

    local description="${props[Description]:-N/A}"
    local load_state="${props[LoadState]:-unknown}"
    local active_state="${props[ActiveState]:-unknown}"
    local sub_state="${props[SubState]:-unknown}"
    local unit_file_state="${props[UnitFileState]:-unknown}"
    local fragment_path="${props[FragmentPath]:-unknown}"
    local result="${props[Result]:-unknown}"
    local exec_status="${props[ExecMainStatus]:--}"
    local condition_result="${props[ConditionResult]:-unknown}"
    local assert_result="${props[AssertResult]:-unknown}"
    local unit_type="${props[Type]:-unknown}"
    local restart_policy="${props[Restart]:-unknown}"
    local nixos_managed_unit="false"
    if _reporting_unit_fragment_is_nixos_managed "$fragment_path"; then
        nixos_managed_unit="true"
    fi

    print_detail "Description: $description"
    print_detail "Load state: $load_state"
    print_detail "Active state: $active_state (sub: $sub_state)"
    print_detail "Unit file state: $unit_file_state"
    if [[ -n "$fragment_path" && "$fragment_path" != "unknown" ]]; then
        print_detail "Fragment path: $fragment_path"
    fi
    if [[ -n "$unit_type" && "$unit_type" != "unknown" ]]; then
        print_detail "Unit type: $unit_type"
    fi
    if [[ -n "$restart_policy" && "$restart_policy" != "unknown" ]]; then
        print_detail "Restart policy: $restart_policy"
    fi

    _print_unit_relationships "Requires units" "${props[Requires]:-}"
    _print_unit_relationships "Wants units" "${props[Wants]:-}"
    _print_unit_relationships "Part of" "${props[PartOf]:-}"
    _print_unit_relationships "Conflicts with" "${props[Conflicts]:-}"
    _print_unit_relationships "After units" "${props[After]:-}"
    _print_unit_relationships "Before units" "${props[Before]:-}"
    _print_unit_relationships "Triggered by" "${props[TriggeredBy]:-}"
    _print_unit_relationships "Triggers units" "${props[Triggers]:-}"
    _print_unit_relationships "Wanted by" "${props[WantedBy]:-}"
    _print_unit_relationships "Required by" "${props[RequiredBy]:-}"

    local enabled_output
    enabled_output=$(systemctl is-enabled "$unit" 2>&1)
    local enabled_rc=$?
    if [[ $enabled_rc -le 1 ]]; then
        print_detail "Enabled: $enabled_output"
    else
        print_detail "Enabled: unknown ($enabled_output)"
    fi

    if [[ "$load_state" != "loaded" ]]; then
        print_warning "$unit load state is '$load_state'; confirm that the unit file is present."
    fi

    if [[ "$active_state" == "failed" || "$result" == "failure" ]]; then
        print_warning "$unit reported a failure state (result: $result)."
    elif [[ "$active_state" != "active" && "$active_state" != "inactive" && "$active_state" != "activating" ]]; then
        print_warning "$unit active state is '$active_state'; review the service behaviour."
    fi

    if [[ -n "$exec_status" && "$exec_status" != "0" && "$exec_status" != "-" ]]; then
        print_warning "$unit exited with status $exec_status; inspect recent logs for details."
    fi

    if [[ "$condition_result" == "no" ]]; then
        print_warning "$unit failed one of its start conditions; inspect Condition directives in the unit file."
    fi

    if [[ "$assert_result" == "no" ]]; then
        print_warning "$unit failed one of its assertions; verify Assert directives."
    fi

    if [[ "$has_nixos_option" == true && "$unit" == *.service && "$unit" != *@* ]]; then
        if _reporting_is_host_managed_unit "$unit"; then
            print_detail "$unit is a host-managed service; skipping declarative definition check."
        elif [[ "$nixos_managed_unit" == "true" ]]; then
            print_detail "$unit is generated by NixOS (unit file sourced from /nix/store); skipping declarative definition warning."
        else
            local option_path
            option_path=$(printf 'systemd.services."%s"' "${unit%.service}")
            if _nixos_option_path_exists "$option_path"; then
                print_detail "Declarative service definition detected: $option_path"
            elif _system_config_declares_service "${unit%.service}"; then
                local source_file="${SYSTEM_CONFIG_FILE:-/etc/nixos/configuration.nix}"
                print_detail "Declarative service definition detected in ${source_file}"
            elif option_path=$(_reporting_lookup_service_option_path "$unit"); then
                print_detail "Declarative service definition detected: $option_path"
            else
                print_warning "No declarative service definition found at $option_path; ensure the service is managed declaratively or documented."
            fi
        fi
    fi

    if [[ "$has_journalctl" == true && ( "$active_state" == "failed" || "$result" == "failure" || ( "$exec_status" != "0" && "$exec_status" != "-" ) ) ]]; then
        local journal_output
        journal_output=$(journalctl -u "$unit" -n 5 --no-pager 2>/dev/null || true)
        if [[ -n "$journal_output" ]]; then
            print_detail "Recent journal entries:"
            while IFS= read -r line; do
                print_detail "  $line"
            done <<< "$journal_output"
        else
            print_detail "No recent journal entries available for $unit."
        fi
    fi

    local unit_definition
    if unit_definition=$(systemctl cat "$unit" 2>/dev/null); then
        _analyze_unit_definition "$unit" "$unit_definition"
    else
        print_detail "Unable to retrieve unit definition for $unit; skipping file-level checks."
    fi

    if [[ "$has_systemd_analyze" == true ]]; then
        if _reporting_is_host_managed_unit "$unit"; then
            print_detail "systemd-analyze verify skipped for host-managed unit $unit."
        else
            local verify_output
            verify_output=$(systemd-analyze verify "$unit" 2>&1 || true)
            if [[ -n "$verify_output" ]]; then
                _report_systemd_verify_output "$unit" "$fragment_path" "$verify_output"
            else
                print_detail "systemd-analyze verify did not report issues for $unit."
            fi
        fi
    fi

    return 0
}

# ============================================================================
# Print Post-Install Report
# ============================================================================
# Purpose: Generate comprehensive post-installation report
print_post_install() {
    print_section "Deployment Report"
    echo ""

    local report_host
    report_host=$(hostname 2>/dev/null || echo "localhost")
    local report_home_user="${PRIMARY_USER:-${USER:-$(id -un 2>/dev/null || echo user)}}"

    # ========================================================================
    # 1. NixOS Generation Information
    # ========================================================================
    print_info "NixOS System Information:"
    echo ""

    # Current generation
    local current_gen
    current_gen=$(sudo nix-env --list-generations -p /nix/var/nix/profiles/system 2>/dev/null | tail -1)
    if [[ -n "$current_gen" ]]; then
        echo "  Generation: $current_gen"
    fi

    # NixOS version
    local nixos_version
    nixos_version=$(nixos-version 2>/dev/null || echo "Unknown")
    echo "  Version: $nixos_version"

    # System configuration path
    if [[ -f "$SYSTEM_CONFIG_FILE" ]]; then
        echo "  Config: $SYSTEM_CONFIG_FILE"
    elif [[ -f "$HM_CONFIG_DIR/configuration.nix" ]]; then
        echo "  Config: $HM_CONFIG_DIR/configuration.nix"
    fi

    # Flake location
    if [[ -f "$FLAKE_FILE" ]]; then
        echo "  Flake: $FLAKE_FILE"
    fi
    echo ""

    # ========================================================================
    # 2. Home-Manager Information
    # ========================================================================
    print_info "Home-Manager User Environment:"
    echo ""

    local hm_gen_line=""
    if hm_gen_line=$(get_home_manager_generation_line); then
        if [[ -n "$hm_gen_line" ]]; then
            echo "  $hm_gen_line"
        fi

        if [[ -f "$HOME_MANAGER_FILE" ]]; then
            echo "  Config: $HOME_MANAGER_FILE"
        fi
    else
        echo "  Status: Home Manager CLI not yet available in PATH"
        echo "  Command: nix run $(get_home_manager_package_ref) -- switch --flake $HM_CONFIG_DIR"
    fi
    echo ""

    # ========================================================================
    # 3. Package Statistics
    # ========================================================================
    print_info "Installed Packages:"
    echo ""

    # System packages
    local system_pkg_count
    system_pkg_count=$(nix-store --query --requisites /run/current-system 2>/dev/null | wc -l)
    echo "  System packages: $system_pkg_count"

    # User packages (if home-manager is active)
    if [[ -d "$HOME/.nix-profile" ]]; then
        local user_pkg_count
        user_pkg_count=$(nix-store --query --requisites "$HOME/.nix-profile" 2>/dev/null | wc -l)
        echo "  User packages: $user_pkg_count"
    fi

    # Flatpak apps
    if command -v flatpak &>/dev/null; then
        local flatpak_count
        flatpak_count=$(flatpak list --app 2>/dev/null | wc -l)
        echo "  Flatpak apps: $flatpak_count"
    fi
    echo ""

    # ========================================================================
    # 4. Service Status Summary
    # ========================================================================
    print_info "System Services Status:"
    echo ""

    local services=(
        "postgresql:Database server"
        "gitea:Git hosting"
    )

    for service_info in "${services[@]}"; do
        local service="${service_info%%:*}"
        local desc="${service_info#*:}"

        if systemctl list-unit-files | grep -q "^${service}.service"; then
            if systemctl is-active --quiet "$service" 2>/dev/null; then
                echo -e "  ${GREEN}●${NC} $service: running ($desc)"
            else
                echo -e "  ${YELLOW}○${NC} $service: stopped ($desc)"
            fi
        else
            echo -e "  ${GRAY}−${NC} $service: not configured ($desc)"
        fi
    done

    if [[ "${LOCAL_AI_STACK_ENABLED:-false}" == "true" ]]; then
        echo ""
        echo "  Podman AI stack containers (vLLM/Open WebUI/Qdrant/MindsDB) are launched by the ai-optimizer workflow."
        if command -v podman-ai-stack >/dev/null 2>&1; then
            echo "  Run 'podman-ai-stack status' after deployment to view their health."
        else
            echo "  Install/configure ai-optimizer to pull and start the containers when ready."
        fi
    fi
    echo ""

    # ========================================================================
    # 4b. AI Stack Cohesion Checks
    # ========================================================================
    print_info "AI Stack Cohesion Checks:"
    echo ""

    local drift_script="${SCRIPT_DIR}/scripts/validate-ai-stack-env-drift.sh"
    if [[ -x "$drift_script" ]]; then
        if "$drift_script"; then
            echo "  Env drift check: OK"
        else
            echo "  Env drift check: FAILED (see output above)"
        fi
    else
        echo "  Env drift check: SKIPPED (script not found)"
    fi
    echo ""

    # ========================================================================
    # 4c. Deployment Error Summary
    # ========================================================================
    if declare -F aggregate_deployment_errors &>/dev/null; then
        aggregate_deployment_errors
        if [[ "${DEPLOY_ERRORS:-0}" -gt 0 || "${DEPLOY_WARNINGS:-0}" -gt 0 ]]; then
            print_info "Deployment Error Summary:"
            echo ""
            echo "  Errors:   ${DEPLOY_ERRORS:-0}"
            echo "  Warnings: ${DEPLOY_WARNINGS:-0}"
            if [[ "${#DEPLOY_ERROR_SAMPLES[@]}" -gt 0 ]]; then
                echo ""
                echo "  Recent errors (last ${#DEPLOY_ERROR_SAMPLES[@]}):"
                local sample
                for sample in "${DEPLOY_ERROR_SAMPLES[@]}"; do
                    # Trim to 120 chars for readability
                    echo "    ${sample:0:120}"
                done
            fi
            echo ""
            echo "  Full log: ${LOG_FILE:-<not set>}"
            echo ""
        else
            print_info "Deployment Error Summary:"
            echo ""
            echo "  No errors or warnings recorded."
            echo ""
        fi
    fi

    # ========================================================================
    # 5. Hardware Summary
    # ========================================================================
    print_info "Hardware Configuration:"
    echo ""

    # CPU
    local cpu_model
    cpu_model=$(lscpu | grep "Model name" | cut -d: -f2 | xargs)
    echo "  CPU: $cpu_model"

    # Memory
    local total_mem
    total_mem=$(free -h | awk '/^Mem:/ {print $2}')
    echo "  Memory: $total_mem"

    # GPU
    if [[ -n "$GPU_TYPE" && "$GPU_TYPE" != "unknown" ]]; then
        echo "  GPU: $GPU_TYPE"
    fi

    # Disk space
    local nix_total
    local nix_used
    local nix_avail
    nix_total=$(df -h /nix | tail -1 | awk '{print $2}')
    nix_used=$(df -h /nix | tail -1 | awk '{print $3}')
    nix_avail=$(df -h /nix | tail -1 | awk '{print $4}')
    echo "  /nix storage: $nix_used used / $nix_total total ($nix_avail available)"
    echo ""

    # ========================================================================
    # 6. Important Paths
    # ========================================================================
    print_info "Important Paths:"
    echo ""
    echo "  Configuration:"
    echo "    System: $SYSTEM_CONFIG_FILE"
    echo "    Home:   $HOME_MANAGER_FILE"
    echo "    Flake:  $FLAKE_FILE"
    echo ""
    echo "  Dotfiles: $DOTFILES_ROOT"
    echo "  Logs:     $LOG_DIR"
    echo ""

    # ========================================================================
    # 7. Next Steps
    # ========================================================================
    print_info "Next Steps:"
    echo ""
    echo "  1. Logout and login to activate all user environment changes"
    echo "  2. Verify services are running:"
    echo "     sudo systemctl status <service-name>"
    echo ""
    echo "  3. Update system configurations:"
    echo "     Edit: $SYSTEM_CONFIG_FILE"
    echo "     Apply: sudo nixos-rebuild switch --flake $HM_CONFIG_DIR#$report_host"
    echo ""
    echo "  4. Update user configurations:"
    echo "     Edit: $HOME_MANAGER_FILE"
    echo "     Apply: home-manager switch --flake $HM_CONFIG_DIR#$report_home_user"
    echo ""
    echo "  5. Update package versions:"
    echo "     cd $HM_CONFIG_DIR && nix flake update"
    echo ""

    # ========================================================================
    # 8. Useful Commands
    # ========================================================================
    print_info "Useful Commands:"
    echo ""
    echo "  # System management"
    echo "  nixos-rebuild switch           # Apply system changes"
    echo "  nixos-rebuild boot             # Apply on next boot"
    echo "  nixos-rebuild test             # Test temporarily"
    echo ""
    echo "  # User environment"
    echo "  home-manager switch            # Apply user changes"
    echo "  home-manager generations       # List generations"
    echo ""
    echo "  # Package management"
    echo "  nix search nixpkgs <query>     # Search for packages"
    echo "  nix-collect-garbage -d         # Clean old generations"
    echo "  nix-store --optimize           # Deduplicate store"
    echo ""
    echo "  # Flake management"
    echo "  nix flake update               # Update flake inputs"
    echo "  nix flake check                # Validate flake"
    echo "  nix develop                    # Enter dev shell"
    echo ""

    # ========================================================================
    # 9. Documentation Links
    # ========================================================================
    print_info "Documentation:"
    echo ""
    echo "  NixOS Manual:       https://nixos.org/manual/nixos/stable/"
    echo "  Home-Manager:       https://nix-community.github.io/home-manager/"
    echo "  Nix Packages:       https://search.nixos.org/packages"
    echo "  Nix Options:        https://search.nixos.org/options"
    echo ""

    # ========================================================================
    # 10. Support and Feedback
    # ========================================================================
    print_info "Support:"
    echo ""
    echo "  Repository: https://github.com/MasterofNull/NixOS-Dev-Quick-Deploy"
    echo "  Issues:     https://github.com/MasterofNull/NixOS-Dev-Quick-Deploy/issues"
    echo ""

    print_success "Deployment report complete!"
    return 0
}
